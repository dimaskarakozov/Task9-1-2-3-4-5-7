// Task9.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
void swap(int* a, int* b) {
	int t = *a;
	*a = *b;
	*b = t;
}
void zadanie1() {
	int i, j,** mas1, *mas2, tuda;
	printf("Введите число строк: ");
	scanf("%d", &j);
	printf("Введите число столбцов: ");
	scanf("%d", &i);
	printf("Выполнить операцию\nтуда - 1\nобратно-2 ?\n");
	scanf("%d", &tuda);
	mas1 = (int**)malloc(i * sizeof(int*));
	mas2 = (int*)malloc( (j *i)* sizeof(int));
	for (int q = 0; q < i; q++ ) {
		mas1[q] = (int*)malloc(j * sizeof(int));
	}

	//выделили память
	if (tuda == 1) {
		for (int w = 0; w < i; w++) {

			for (int q = 0; q < j; q++) {
				printf("Введите значение: ");
				scanf("%d", &mas1[w][q]);
			}
		}
		printf("Начальный массив:");
		for (int w = 0; w < i; w++) {
			printf(" \n");
			for (int q = 0; q < j; q++) {
				printf("\t%d", mas1[w][q]);
			}
		}
		printf("\nПеределанный туда");
		for (int w = 0; w < i; w++) {
			for (int q = 0; q < j; q++) {
				mas2[w * q + q] = mas1[w][q];
				printf("\t%d", mas2[w * q + q]);
			}
		}
	}
	else if (tuda == 2) {

		for (int w = 0; w < i*j; w++) {

				printf("Введите значение: ");
				scanf("%d", &mas2[w]);
			
		}
		printf("Начальный массив:");
		for (int w = 0; w < i*j; w++) {
				printf("\t%d", mas2[w]);
		}

		printf("\nПеределанный обратно\n");
		for (int w = 0; w < i; w++) {
			printf("\n");
			for (int q = 0; q < j; q++) {
				 mas1[w][q]= mas2[w*j + q];
				 printf("\t%d", mas1[w][q]);
			}
		}

	}
	else {
		printf("Вы не правильно ввели данные");
	}

}
void zadanie2() {
	int mas[5][5];

		for (int i = 0; i < 5; i++) {
			for (int j = 0; j < 5; j++) {

				mas[i][j] = j + 1-i;
				if (mas[i][j] <= 0) {   
					mas[i][j] = 2 - mas[i][j] ;
				}
			}
		}
	

	for (int i = 0; i < 5; i++) {  //вывод
		printf("\n");
		for (int j = 0; j < 5; j++) {
			printf("\t%d",mas[i][j]);
			mas[i][j] = 0;
		}
	}
	printf("\n\n");

	int m = 1;


	
		mas[2][2] = 25; 

	for (int i = 0; i < 2; i++) {
		for (int j = i; j < (5 - i); j++) {  
			mas[i][j] = m;
			m++;
		}
		for (int j = 1; j < (5 - i - i); j++) { 
			mas[(j + i)][(5 - i) - 1] = m;   
			m++;
		}
		for (int j = 3 - i; j >= i; j--) {  
			mas[(5 - i) - 1][(j)] = m;     
			m++;
		}
		for (int j = ((5 - i) - 2); j > i; j--) {
			mas[j][i] = m;
			m++;
		}
	}
			

			for (int i = 0; i < 5; i++) {  //вывод
				printf("\n");
				for (int j = 0; j < 5; j++) {
					printf("\t%d", mas[i][j]);
				}
			}
		


}
void zadanie3() {
	int  mas[9][9],sum=0,e;


	
	for (int i = 0; i < 9; i++) {  //ввод
		for (int j = 0; j < 9; j++) {
			printf("\nВведите число(%d %d)", i, j);
			scanf("%d", &mas[i][j]);
			//mas[i][j] = i + j;  //  пример заполнения
		}
	}
	


	for (int i = 0; i < 9; i++) {
		if (i<4) {
			e = i;
		}
		else{
			e = 8 - i;
		}

		for (int j = e; j < 9 - e; j++) {
			sum = sum + mas[i][j];
			//printf(" %d ", mas[i][j]); проверочка
		}
	}

	printf("%d\n",sum);

	for (int i = 0; i < 9; i++) { 
		printf("\n");
		for (int j = 0; j < 9; j++) {
			printf("\t%d", mas[i][j]);

		}
	}
}

void zadanie4() {
	int i, j, ** mas,sum=0;
	printf("Введите число строк: ");
	scanf("%d", &i);
	printf("Введите число столбцов: ");
	scanf("%d", &j);
	mas = (int**)malloc( i * sizeof(int*));
	for (int q = 0; q < i; q++) {
		mas[q] = (int*)malloc((j+1) * sizeof(int));
	}

	//выделили память

	for (int w = 0; w < j; w++) {
		for (int q = 0; q < i; q++) {
			printf("Введите значение(%d %d): ", q, w);
			scanf("%d", &mas[q][w]);
		}
	}


	for (int w = 0; w < i; w++) {
		mas[w][j + 1] = 0;

		for (int q = 0; q < j; q++) {
			mas[w][j + 1] = mas[w][j + 1] + mas[w][q];
			//printf("%d ", mas[w][j + 1]);  // проверочка
		}
	}


	
		for (int w = 0; w <j; w++) {  //печатать массив данный
			printf("\n");
			for (int q = 0; q < i; q++) {
				printf("\t %d", mas[q][w]);

			}
		}
		printf("\n");
		for (int q = 0; q < i; q++) { //печатать сумму столбцов
			printf("\t %d", mas[q][j+1]);

		}



//puzir   
		
// в качестве примера взял сортировку пузырьком,знаю что в этом методе очень много перестановок,но для примера думаю пойдет.
	//код сортировки скопировал с моего таска 6, только изменил алгоритм изменения элементов
		int max;
	int i1, j1;
	for (i1 = 1; i1 < i; i1++) {

		max = 0;
		for (j1 = 0; j1 < i - i1; j1++) {

			if (mas[j1][j + 1] > mas[j1 + 1][j + 1]) {
				for (int t = 0; t < j;t++) {
					swap(&mas[j1][t], &mas[j1 + 1][t]);
				}
				swap(&mas[j1][j + 1], &mas[j1+1][j + 1]);
				
				
				max = 1;
			}



		}
		if (max == 0) {
			i1 = i;
		}

	}

	for (int w = 0; w < j; w++) {  //печатать массив готовый
		printf("\n");
		for (int q = 0; q < i; q++) {
			printf("\t %d", mas[q][w]);

		}
	}
	printf("\n");
	for (int q = 0; q < i; q++) { //печатать сумму столбцов (после сорта)
		printf("\t %d", mas[q][j + 1]);

	}


}


void gaussMethod(
	int m,          // Число строк матрицы
	int n,          // Число столбцов матрицы
	double* a,      // Адрес массива элементов матрицы
	double eps      // Точность вычислений
) {
	int i, j, k, l;
	double r;

	i = 0; j = 0;
	while (i < m && j < n) {
		// Инвариант: минор матрицы в столбцах 0..j-1
		//   уже приведен к ступенчатому виду, и строка
		//   с индексом i-1 содержит ненулевой эл-т
		//   в столбце с номером, меньшим чем j

		// Ищем максимальный элемент в j-м столбце,
		// начиная с i-й строки
		r = 0.0;
		for (k = i; k < m; ++k) {
			if (fabs(a[k * n + j]) > r) {
				l = k;      // Запомним номер строки
				r = fabs(a[k * n + j]); // и макс. эл-т
			}
		}
		if (r <= eps) {
			// Все элементы j-го столбца по абсолютной
			// величине не превосходят eps.
			// Обнулим столбец, начиная с i-й строки
			for (k = i; k < m; ++k) {
				a[k * n + j] = 0.0;
			}
			++j;      // Увеличим индекс столбца
			continue; // Переходим к следующей итерации
		}

		if (l != i) {
			// Меняем местами i-ю и l-ю строки
			for (k = j; k < n; ++k) {
				r = a[i * n + k];
				a[i * n + k] = a[l * n + k];
				a[l * n + k] = (-r); // Меняем знак строки
			}
		}

		// Утверждение: fabs(a[i*n + k]) > eps

		// Обнуляем j-й столбец, начиная со строки i+1,
		// применяя элем. преобразования второго рода
		for (k = i + 1; k < m; ++k) {
			r = (-a[k * n + j] / a[i * n + j]);

			// К k-й строке прибавляем i-ю, умноженную на r
			a[k * n + j] = 0.0;
			for (l = j + 1; l < n; ++l) {
				a[k * n + l] += r * a[i * n + l];
			}
		}

		++i; ++j;   // Переходим к следующему минору
	}


}

void treug(int qwe,int n) {
	int  m, i, j, rank;
	double* a;
	double eps, det;

	printf("Введите размеры матрицы m, n: ");
	scanf("%d", &m);
	n=n+m;
	// Захватываем память под элементы матрицы
	a = (double*)malloc(m * n * sizeof(double));

	printf("Введите элементы матрицы:\n");
	for (i = 0; i < m; ++i) {
		for (j = 0; j < n; ++j) {
			// Вводим элемент с индексами i, j
			scanf("%lf", &(a[i * n + j]));
		}
	}

	printf("Введите точность вычислений eps: ");
	scanf("%lf", &eps);

	// Вызываем метод Гаусса
	gaussMethod(m, n, a, eps);

	// Печатаем ступенчатую матрицу
	printf("Треугольный вид матрицы:\n");
	for (i = 0; i < m; ++i) {
		// Печатаем i-ю строку матрицы
		for (j = 0; j < n; ++j) {
			printf(         // Формат %10.3lf означает 10
				"%10.3lf ", // позиций на печать числа,
				a[i * n + j]  // 3 знака после точки
			);
		}
		printf("\n");   // Перевести строку
	}



	if (qwe == 7) {
		det = 1.0;
		for (i = 0; i < m ; ++i) {
			det = det * a[i * n + i];
		}
		printf("Определитель матрицы = %.3lf\n", det);
	}
	if (n != m )
	{
		j = 1;
		i = n * m - 2;
		while ( i>0 ) {
			
			
			a[i + j] = a[i + j] / a[i];
			a[i] = 1;
			for (int k = 0; k < m-j ; k++) {
				a[i + j-n -n*k ] = a[i + j-n - n * k] - (a[i-n]* a[i + j - n * k]);
				a[i-n - n * k] = 0;
				
			}

			j++;
			i = i - n-1;
		}
		a[m] = a[m] / a[0];
		a[0] = 1;


		printf("Ответ:\n");
		for (i = 0; i < m; ++i) {
			// Печатаем i-ю строку матрицы
			for (j = 0; j < n; ++j) {
				printf(         // Формат %10.3lf означает 10
					"%10.3lf ", // позиций на печать числа,
					a[i * n + j]  // 3 знака после точки
				);
			}
			printf("\n");   // Перевести строку
		}

	}
	

}

void zadanie5(){
	treug(0, 1);
}
void zadanie6() {
	printf("В разработке...");
}
void zadanie7() {

	treug(7,0);
}


int main()
{

	
		int q = -1;
		setlocale(LC_ALL, "Russian");

		//Task6

		printf("\n\n1) (1)  Считаем, что двумерный массив размера m на n преобразуется в одномерный массив размера m* n путем последовательной записи строк. (m и n заданы) Реализовать такое преобразование «туда» и «обратно».  ");
		printf("\n\n2) (2) Заполнить двумерный массив размером n x m так, как представлено в таблице для 5х5");
		printf("\n\n3) (1) - Дан квадратный массив целых чисел 9 х 9. Вычислить сумму элементов из заштрихованной области. Вывести значение суммы на печать. (один из двух вариантов)");
		printf("\n\n4) (1) - Отсортировать двумерный массив по возрастанию сумм/произведений элементов столбцов/строк 	");
		printf("\n\n5) (2) Решить систему линейных уравнений методом Гаусса(n уравнений, n неизвестных)");
		printf("\n\n6) (2) Найти обратную матрицу методом Гаусса (сделать проверку)");
		printf("\n\n7) (2) Найти определитель матрицы, путем приведения к диагональному виду");
		printf("\n\n0)Выйти");
		while (q != 0) {
			printf("\n\nВведите номер нужного задания : ");
			scanf_s("%d", &q);
			switch (q) {
			case 1: {
				zadanie1();//Задание 1
				break;
			}
			case 2: {
				zadanie2();//Задание 2
				break;
			}
			case 3: {
				zadanie3();//Задание 3
				break;
			}
			case 4: {
				zadanie4();//Задание 4
				break;
			}
			case 5: {
				zadanie5();//Задание 5
				break;
			}
			case 6: {
				zadanie6();//Задание 5
				break;
			}
			case 7: {
				zadanie7();//Задание 5
				break;
			}
			}
		}
		return 0;
  
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
